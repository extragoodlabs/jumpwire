defmodule JumpWire.Cloak.Storage.AWS.KMS do
  @moduledoc """
  Load keys from AWS KMS. A single master key is used per org. Each time this module
  is called to load keys, a new data key is generated using that master key.
  """

  require Logger
  alias JumpWire.Cloak.Keys
  alias JumpWire.AWS.KMS

  @behaviour JumpWire.Cloak.Storage

  @impl true
  def load_keys(_config) do
    # KMS master keys are always org scoped.
    %{}
  end

  @impl true
  def load_keys(_config, org_id) do
    Logger.debug("Loading a new key from AWS KMS")
    key_name = Application.get_env(:jumpwire, __MODULE__)
    |> Keyword.fetch!(:key_name)
    |> KMS.key_alias(org_id)

    with {:ok, %{"CiphertextBlob" => ciphertext,
                 "Plaintext" => key,
                 "KeyId" => key_id}} <- KMS.generate_key(key_name),
         {:ok, ciphertext} <- JumpWire.Base64.decode(ciphertext),
         {:ok, key} <- JumpWire.Base64.decode(key) do
      aes_gcm = Keys.aes_config(key) |> Keys.with_extra_opts(encrypted_key: ciphertext)
      aes_cbc = Keys.aes_cbc_config(aes_gcm)
      aes_ecb = Keys.aes_ecb_config(aes_gcm)
      cipher = Keys.kms_config(key_id, [aes_gcm, aes_cbc, aes_ecb])
      [aes: cipher, aes_cbc: cipher, aes_ecb: cipher]
    else
      err ->
        Logger.error("Unable to generate key: #{inspect err}")
        []
    end
  end

  @impl true
  def save_keys(_config, _org_id) do
    # Encrypted keys are stored with the data. There's nothing to
    # write back to KMS.
    :ok
  end

  @impl true
  def delete_key(_config, _key, _module) do
    # Since there's no storage, deleting a data key generated by
    # KMS means just removing it from the key ring.
    :ok
  end
end
