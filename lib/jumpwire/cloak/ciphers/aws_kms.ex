defmodule JumpWire.Cloak.Ciphers.AWS.KMS do
  @moduledoc """
  A `Cloak.Cipher` which wraps keys generated by AWS KMS.

  Encryption and decryption are done by AES ciphers using keys generated from KMS. Metadata
  specifying the KMS master key and an encrypted data key are encoded and prepended to the ciphertext.
  """

  @behaviour Cloak.Cipher

  alias Cloak.Tags.{Encoder, Decoder}
  require Logger

  @type data_key() :: {
    key_id :: String.t(),
    cipher :: {module :: module(), opts :: Keyword.t()},
  }

  @type opts() :: %{
    keys: [data_key()],
    tag: String.t(),
    key_id: String.t(),
  }

  @doc """
  Callback implementation for `Cloak.Cipher`. Encrypts a value using
  an AES key from KMS and adds that encrypted key as metadata.

  The format can be diagrammed like this:

      +---------------------------------------------------------------------------------------+
      |                 HEADER                                         |         BODY         |
      +-------------------+------------------+-------------------------+----------------------+
      | Key Tag (n bytes) | Key ID (n bytes) | Encrypted Key (n bytes) | Ciphertext (n bytes) |
      +-------------------+------------------+-------------------------+----------------------+
      |                   |_________________________________
      |                                                     |
      +---------------+-----------------+-------------------+
      | Type (1 byte) | Length (1 byte) | Key Tag (n bytes) |
      +---------------+-----------------+-------------------+

  The `Key Tag` component of the header breaks down into a `Type`, `Length`,
  and `Value` triplet for easy decoding.

  The `Key ID` is an identifier from AWS, usually a UUID but it could also be an alias or ARN.

  The `Encrypted Key` component is the AES key used to encrypt and decrypt the data. The key itself is encrypted
  using the AWS KMS master key and can be decrypted with an API call to KMS.


  [Diagram of the full encoding process](https://excalidraw.com/#json=uGPjlxla_EOUsXDhibVwC,14JgDjXHRc2YTyXgAWifhQ)
  """
  @impl true
  def encrypt(plaintext, opts) do
    tag = Keyword.fetch!(opts, :tag)
    id = Keyword.fetch!(opts, :key_id)

    # Use the first cached data key for encrypting.
    [{mod, mod_opts} | _rest] = Keyword.fetch!(opts, :keys)
    key = Keyword.fetch!(mod_opts, :encrypted_key)

    with {:ok, ciphertext} <- mod.encrypt(plaintext, mod_opts) do
      encoded = Encoder.encode(tag) <>
        Encoder.encode(id) <>
        Encoder.encode(key) <>
        ciphertext

      {:ok, encoded}
    end
  end

  @impl true
  def decrypt(ciphertext, opts) do
    # Decode the key ID and encrypted key blob from the ciphertext
    with {:ok, ciphertext} <- decode_tag(ciphertext, opts),
         %{remainder: ciphertext, tag: _kms_key_id} <- Decoder.decode(ciphertext),
         %{remainder: ciphertext, tag: key} <- Decoder.decode(ciphertext),
         %{tag: tag} <- Decoder.decode(ciphertext),
         {:ok, {mod, opts}} <- find_cipher(tag, key, opts) do
      # Once all the metadata has been decoded, decrypt the data using the AES key embedded in the KMS
      # cipher. If this is the first time seeing this data key it will be decrypted and cached
      # in the `find_cipher/3` call.
      mod.decrypt(ciphertext, opts)
    end
  end

  @impl true
  def can_decrypt?(ciphertext, opts) do
    tag = Keyword.fetch!(opts, :tag)
    case Decoder.decode(ciphertext) do
      %{tag: ^tag} -> true
      _ -> false
    end
  end

  defp decode_tag(ciphertext, opts) do
    tag = Keyword.fetch!(opts, :tag)
    case Decoder.decode(ciphertext) do
      %{remainder: remainder, tag: ^tag} -> {:ok, remainder}
      _ -> :error
    end
  end

  def find_cipher(tag, encrypted_key, opts) do
    data_keys = Keyword.fetch!(opts, :keys)

    case Enum.find(data_keys, fn {_mod, opts} -> tag == opts[:tag] end) do
      nil ->
        # Decode the key from AWS and return a usable
        # Cloak cipher to add to the key ring.
        with {:ok, key} <- JumpWire.AWS.KMS.decrypt(encrypted_key) do
          aes_gcm = JumpWire.Cloak.Keys.aes_config(key) |> JumpWire.Cloak.Keys.with_extra_opts(encrypted_key: encrypted_key)
          aes_cbc = JumpWire.Cloak.Keys.aes_cbc_config(aes_gcm)
          aes_ecb = JumpWire.Cloak.Keys.aes_ecb_config(aes_gcm)
          updater = fn opts ->
            Keyword.update!(opts, :keys, fn keys -> [aes_gcm, aes_cbc, aes_ecb | keys] end)
          end
          {:update_cipher, updater}
        end

      cipher ->
        # Found a cached data key matching this ciphertext
        {:ok, cipher}
    end
  end
end
